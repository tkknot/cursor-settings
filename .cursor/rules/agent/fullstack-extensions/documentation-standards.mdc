---
alwaysApply: false
---
# 文書化・コメント標準ガイドライン

## 概要
このガイドラインは、`@.cursor\rules\agent\fullstack-programmer.mdc` の拡張ファイルとして、高品質なコメント作成とMermaidダイアグラムを活用した視覚的コミュニケーションの実践方法を詳細に説明します。

# 第1部: コメント標準

## コメント記載方針

### 基本原則
```
□ WHY重視: 実装理由・設計判断の背景を説明（WHATではなく）
□ 意図明確: 複雑なロジック・アルゴリズムの目的・戦略
□ 制約説明: 技術的制約・業務ルール・外部仕様による制限
□ 将来考慮: 拡張予定・技術負債・リファクタリング方針
□ 注意喚起: 副作用・パフォーマンス影響・セキュリティ考慮点
```

### WHYを重視したコメント例
適切なコメント記載の対比：
- 不適切例: 「ユーザー配列をループする」（何をしているかを説明）
- 適切例: 「パフォーマンス上の理由でforEachではなく通常のforループを使用。大量データ（10万件超）の処理で約30%の速度改善を確認」（なぜその実装を選んだかを説明）

## コメント記載箇所

### 必須コメント箇所
```
□ クラス・関数定義: 目的・責務・使用方法
□ 複雑な処理: アルゴリズム・計算式・データ変換ロジック
□ 外部依存: API呼び出し・DB操作・ファイル操作
□ 設定・定数: マジックナンバー・設定値の意味・調整指針
□ エラー処理: 例外発生条件・回復方法・影響範囲
□ パフォーマンス最適化: 最適化理由・トレードオフ・測定結果
□ セキュリティ対策: 脅威・対策方法・検証方法
□ 一時的措置: TODOコメント・ワークアラウンド・暫定対応
```

### クラス・関数定義の例
関数文書化の要素：
- 目的の説明: 関数が何を実現するかの概要
- 実装詳細: タイムアウト設定、再試行回数等の重要な仕様
- パラメータ文書: 型、説明、制約事項
- 戻り値文書: 戻り値の型と内容
- 例外文書: 発生可能な例外と条件
- 使用例: 実際の呼び出しパターンの提示

### 複雑な処理の例
高度なアルゴリズムの文書化要素：
- アルゴリズム選択理由: マトリックス乗算によるフィボナッチ数列計算の採用理由
- 計算量の説明: O(n)からO(log n)への改善効果
- 参考資料: アルゴリズムの出典・詳細説明へのリンク
- 実装の詳細: 基底マトリックス、バイナリ指数法の説明
- 処理ステップ: 主要な計算手順の概要

## わかりやすいコメント作成

### 作成指針
```
□ 読み手視点: 実装者以外が理解できる表現・専門用語説明
□ 具体的記述: 抽象的表現を避け、具体例・数値を含む
□ 簡潔性: 必要十分な情報を過不足なく記載
□ 構造化: 箇条書き・段落分けで読みやすく整理
□ 更新性: コード変更時にコメントも同期更新
```

### 具体的なコメント例
効果的なコメントの対比：
- 不適切例: 「キャッシュを処理する」（抽象的で不明確）
- 適切例: 「メモリ使用量が80%を超えた場合のガベージコレクション。処理時間は平均50ms、最大でも200msで完了する設計」（具体的な条件・処理内容・性能データを含む）

## コメント種類・フォーマット

### 標準コメント種類
```
□ API文書: 関数・クラスの仕様（引数・戻り値・例外）
□ 実装コメント: 内部ロジック・処理フロー説明
□ TODOコメント: 将来作業・改善点（期限・担当者含む）
□ FIXMEコメント: 既知の問題・バグ（影響・回避策含む）
□ NOTEコメント: 重要な情報・注意点・参考情報
□ HACKコメント: 技術的妥協・回避策（理由・リスク含む）
```

### フォーマット例
各コメント種類の具体的な記載内容：
- TODO: 期限・担当者・対応内容を明記（例：多要素認証対応の予定）
- FIXME: 重要度・問題内容・現在の回避策を説明（例：レース条件問題）
- NOTE: 重要な背景情報・制約事項・将来の変更予定
- HACK: 技術的妥協の理由・影響範囲・解決予定を明記

## コメント品質・保守

### 品質基準
```
□ 正確性: 実装と齟齬のない正確な情報
□ 最新性: コード変更時のコメント同期更新
□ 一貫性: プロジェクト全体で統一されたスタイル・記法
□ 不要コメント削除: 自明・重複・古いコメントの定期的削除
□ レビュー対象: コメントもコードレビューの対象として品質確保
```

### コメント更新チェックリスト
プルリクエスト時の確認項目：
- 正確性: コメントの内容は実装と一致しているか？
- 必要性: このコメントは本当に必要か？
- 明確性: チームメンバーが理解できる内容か？
- 保守性: 将来のメンテナンスを考慮しているか？
- 一貫性: プロジェクトの標準フォーマットに従っているか？

## 避けるべきコメントパターン

### アンチパターン
```
□ 自明な内容: コードを読めば分かる処理の逐一説明
□ 古い情報: 過去の実装・仕様を参照する時代遅れコメント
□ 感情表現: 愚痴・批判・個人的感想の記載
□ 冗長な説明: 過度に詳細で本質を見失う説明
□ 不正確な情報: 推測・憶測に基づく曖昧な記述
```

### 具体的なアンチパターン例
避けるべきコメントパターンの具体例：
- 自明な内容: 「変数iを0で初期化」（コードを見れば分かる）
- 古い情報: 「旧システムのAPIとの互換性のため」（既に廃止済みシステムへの言及）
- 感情表現: 「この処理は本当にひどい実装だが」（建設的でない批判）
- 冗長な説明: 処理の詳細を逐一説明する長文コメント
- 適切な例: 「文字列から数値を抽出（例: "price:100" → 100）」（簡潔で目的が明確）

# 第2部: Mermaidダイアグラム活用

## 視覚的コミュニケーション原則

### 基本原則
```
□ 視覚優先: 複雑な概念・関係性はmermaidダイアグラムで表現
□ 理解促進: テキストのみでは伝わりにくい内容を図解で補完
□ 共通認識: チーム内でのイメージ統一・議論の起点として活用
□ 文書化: 設計・仕様書への図表埋め込みで可読性向上
□ 学習支援: 複雑なロジック・システムの理解を図解で支援
```

### いつダイアグラムを作成するか
- **システム設計時**: アーキテクチャの全体像共有
- **複雑な処理の説明**: アルゴリズムやワークフローの解説
- **問題分析時**: バグや課題の影響範囲可視化
- **レビュー時**: 設計や実装の説明資料
- **教育・引き継ぎ**: 新メンバーへの知識共有

## Mermaid使用場面・ダイアグラム種類

### 主要ダイアグラム種類
```
□ システムアーキテクチャ: graph/flowchartでシステム全体構成
□ 処理フロー: flowchartでアルゴリズム・業務プロセス
□ データフロー: graph LRでデータ変換・加工の流れ
□ API通信: sequenceDiagramでリクエスト・レスポンスの流れ
□ 状態遷移: stateDiagramでオブジェクト・画面の状態変化
□ データベース設計: erDiagramでテーブル関係・制約
□ クラス設計: classDiagramで継承・依存関係
□ 開発スケジュール: ganttでタスク・マイルストーン管理
```

### システムアーキテクチャ例
システム全体構成図の要素：
- ユーザー層: エンドユーザーのアクセスポイント
- 負荷分散層: ロードバランサーによるトラフィック分散
- Webサーバー層: 複数サーバーでの冗長化
- APIゲートウェイ: 各種サービスへのアクセス制御
- マイクロサービス: 認証・注文・決済の独立したサービス
- データ層: 各サービス専用のデータベース

### 処理フロー例
業務プロセスフローの要素：
- 開始・終了ポイント: 処理の境界を明確化
- 入力・検証: ユーザー入力とバリデーション処理
- 分岐判定: 成功・失敗条件による処理分岐
- エラーハンドリング: 失敗時の処理とリトライ機能
- 最終結果: 成功・失敗の最終状態への到達

### シーケンス図例
API通信フローの要素：
- 参加者定義: User、Frontend、API、Database、Payment Gateway
- 操作の流れ: 注文確定から完了画面表示までの時系列
- データフロー: リクエスト・レスポンスの往復通信
- 外部システム連携: 決済ゲートウェイとの通信
- エラーハンドリング: 各ステップでの失敗処理

## ダイアグラム品質・設計原則

### 設計原則
```
□ 簡潔性: 1つのダイアグラムに詰め込み過ぎず、焦点を明確化
□ 一貫性: 命名・表記ルールをプロジェクト全体で統一
□ 階層化: 詳細度に応じてダイアグラムを段階的に分割
□ 最新性: コード・仕様変更時のダイアグラム同期更新
□ 可読性: ノード・エッジのラベルは分かりやすく具体的に
```

### ダイアグラム階層化の例
段階的詳細化のアプローチ：
- Level 1（全体概要）: Frontend - Backend - Database の大まかな構成
- Level 2（Backend詳細）: APIゲートウェイ、各マイクロサービス、データベースの詳細構成
- 各レベルで適切な抽象化度を維持し、情報過多を避ける

## 具体的活用パターン

### 活用シーン
```
□ 設計説明: 新機能・システム設計の提案・レビュー時
□ バグ調査: 問題発生箇所・影響範囲の可視化
□ リファクタリング: 変更前後の構造比較・影響分析
□ 学習・教育: 新メンバーへの技術・業務説明
□ 仕様書作成: 要件定義・設計書での図表活用
□ 進捗報告: 開発状況・課題の視覚的共有
```

### バグ調査での活用例
問題解決フローの可視化要素：
- 問題報告: ユーザーからの具体的な問題報告
- 再現性確認: 問題の再現可能性の検証
- 調査分岐: ログ調査・環境差異調査の選択
- 原因特定: API・データベース・ネットワーク各層での問題発見
- 解決策実行: 各原因に対する具体的な修正作業
- 視覚的強調: 問題箇所の色分けによる識別

## ダイアグラム保守・管理

### 管理方針
```
□ バージョン管理: ダイアグラムもソースコードと同様に管理
□ 自動生成: 可能な限りコードから自動生成・同期
□ レビュー対象: ダイアグラムもコードレビューの対象として品質確保
□ アーカイブ: 過去の設計判断・変遷を記録として保持
□ 共有・検索: チーム内でのダイアグラム共有・再利用促進
```

### 自動生成の例
アーキテクチャ図の自動生成アプローチ：
- サービス定義: 各サービスとその依存関係をデータ構造で定義
- Mermaid生成: 定義されたデータからMermaid記法を自動構築
- 動的更新: システム構成変更時の図表自動更新
- 一貫性保証: 実装とドキュメントの同期維持

## 効果的なダイアグラム作成のコツ

### 作成手順
```
□ 目的明確化: 何を伝えたいかを明確にしてから作成開始
□ 段階的詳細化: 概要から詳細へ、段階的に情報を追加
□ 関係性重視: ノードより関係性・データフローに焦点
□ 色・形状活用: 重要度・種類に応じた視覚的差別化
□ フィードバック活用: レビュー・質問を受けてダイアグラム改善
```

### スタイル活用例
色・形状による視覚的差別化の効果：
- 成功処理: 緑系の色で成功状態を強調
- エラー処理: 赤系の色でエラー状態を明示
- 通常処理: 青系の色で標準的な処理を表現
- クラス定義: 処理種別ごとの統一されたスタイル適用

## 品質管理・継続的改善

### ダイアグラム品質チェックリスト
```
□ 目的に適したダイアグラム種類の選択
□ 情報の過不足がない適切な抽象化レベル
□ 一貫した命名規則・表記法の使用
□ 実装との整合性確保
□ 視覚的な見やすさ・理解しやすさ
□ 更新頻度・メンテナンス性の確保
```

### 継続的改善
- **利用状況分析**: どのダイアグラムが活用されているか
- **フィードバック収集**: チームメンバーからの改善提案
- **標準化推進**: 効果的なパターンの標準化・テンプレート化
- **ツール評価**: より良いダイアグラム作成ツールの検討

## 参考リソース

### 関連ファイル
- メインルール: `@.cursor\rules\agent\fullstack-programmer.mdc`
- ログ実装: `@.cursor\rules\agent\fullstack-extensions\logging-guidelines.mdc`
- リファクタリング: `@.cursor\rules\agent\fullstack-extensions\refactoring-cookbook.mdc`

### 推奨ツール・リソース
- **Mermaid公式**: https://mermaid.js.org/
- **Live Editor**: https://mermaid.live/
- **VSCode拡張**: Mermaid Preview
- **GitHub統合**: GitHub内でのMermaid自動レンダリング
- **文書化ツール**: GitBook, Notion, Confluence with Mermaid support

