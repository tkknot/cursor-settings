---
alwaysApply: false
---

# リファクタリング実践クックブック

## 概要
このクックブックは、`@.cursor\rules\agent\fullstack-programmer.mdc` の拡張ファイルとして、安全で効果的なリファクタリング手法を詳細に説明します。小さく安全な改善から大規模な構造変更まで、実践的なガイドを提供します。

## リファクタリングの原則・目的

### 基本原則
```
□ 継続的改善: 小さく頻繁なリファクタリングで品質維持
□ 機能保持: 外部動作を変えずに内部構造のみ改善
□ 設計改善: 可読性・保守性・拡張性・テスタビリティ向上
□ 技術負債解消: コードスメル・重複・複雑性の除去
□ パフォーマンス最適化: 効率的なアルゴリズム・データ構造への変更
```

### リファクタリングの価値
- **保守性向上**: コードの理解・修正が容易になる
- **品質向上**: バグの発生率低下、テスタビリティ改善
- **開発効率**: 新機能追加・変更の高速化
- **技術負債解消**: 将来のメンテナンスコスト削減

## リファクタリングのタイミング

### 適切なタイミング
```
□ 新機能追加前: 拡張しやすい構造への改善
□ バグ修正時: 問題の根本原因となる設計問題の解決
□ コードレビュー時: レビューで発見された改善点の対応
□ テスト作成時: テストしやすい構造への変更
□ パフォーマンス問題発生時: ボトルネック解消のための最適化
□ 定期メンテナンス: 計画的な技術負債解消
```

### タイミング判断の実例
新機能追加前のリファクタリングアプローチ：
- 変更前の状況: 長大な関数（100行超）に複数の責務が混在
- 問題点: 注文処理、在庫確認、決済、メール送信の責務が未分離
- 改善後: 各責務を個別関数に分離し、メイン関数は処理フローのみ管理
- 効果: 新機能（認証）の追加が容易になり、テストも書きやすくなる

## リファクタリング手法・パターン

### 基本的なリファクタリング手法
```
□ 関数抽出: 長い関数・重複コードの分割・共通化
□ 変数・関数名変更: 意図を明確にする命名への改善
□ 条件式統合: 複雑な条件分岐の簡略化・可読性向上
□ クラス分割: 単一責任原則に基づく責務の適切な分離
□ インターフェース抽出: 依存関係の疎結合化・テスタビリティ向上
□ マジックナンバー除去: 定数化による保守性・可読性向上
□ デッドコード削除: 使用されないコード・変数の除去
□ デザインパターン適用: 適切なパターンによる設計改善
```

### 1. 関数抽出（Extract Function）

#### 適用場面
- 関数が長すぎる（20行超目安）
- 重複したコードブロックがある
- コメントで説明が必要な処理ブロック

#### 実装例
関数抽出の段階的アプローチ：
- 変更前: 長い関数内に統計計算・HTML生成が混在
- 問題特定: 単一関数内の複数責務、テストの困難さ
- 分離戦略: 統計計算とHTML生成を独立した関数に分離
- 改善効果: 各関数が単一責務を持ち、個別テストが可能に
- 再利用性: 統計計算部分は他の用途でも再利用可能

### 2. 条件式統合（Consolidate Conditional Expression）

#### 実装例
条件式統合のリファクタリング手法：
- 変更前: 重複する条件判定（isPremium）と複雑な条件分岐
- 問題点: 条件の重複、可読性の低下、保守性の問題
- 統合戦略: 共通条件の早期リターンと機能別関数への分離
- 改善効果: 各割引種別が独立した関数で管理され、テスト・保守が容易
- 拡張性: 新しい割引種別の追加が既存コードに影響しない

### 3. クラス分割（Extract Class）

#### 実装例
クラス分割による責務分離の手法：
- 変更前: 単一クラスにユーザー管理・注文管理・設定管理・通知機能が混在
- 問題点: 単一責任原則違反、テストの困難さ、変更影響の拡大
- 分離戦略: 各責務を専門クラスに分離し、コンポジションパターンで組み合わせ
- 改善効果: 各クラスが単一責務を持ち、独立したテスト・保守が可能
- 拡張性: 新機能追加時の影響範囲の局所化

## リファクタリング実行時の安全策

### 安全策チェックリスト
```
□ テストカバレッジ確保: リファクタリング前の包括的テスト作成
□ 小さな単位で実行: 一度に変更する範囲を最小限に抑制
□ バージョン管理活用: 細かいコミット・ブランチでの安全な作業
□ 自動テスト実行: 各ステップでのテスト実行・回帰チェック
□ ペアプログラミング: チームメンバーとの協働による品質確保
□ ステージング検証: 本番環境に近い環境での動作確認
```

### 段階的リファクタリングの実例
安全な段階的リファクタリングのプロセス：
- Stage 1（テスト作成）: 既存動作を保証するテストを最初に作成
- Stage 2（最小変更）: 元の実装を単純に関数として抽出
- Stage 3（内部改善）: reduceメソッドを使用した効率的な実装に改善
- Stage 4（さらなる抽出）: ヘルパー関数を作成して可読性・再利用性を向上
- 各ステージでテスト実行により安全性を確保

## リファクタリング品質評価

### 評価指標
```
□ 可読性向上: コードの理解しやすさ・複雑度の改善測定
□ 保守性向上: 変更容易性・影響範囲の局所化達成度
□ テスタビリティ向上: テスト作成・実行の容易性改善
□ パフォーマンス改善: 実行時間・メモリ使用量の測定・比較
□ 結合度低下: モジュール間依存関係の疎結合化達成度
□ 凝集度向上: 単一責任原則の達成度・機能の集約度
```

### 測定ツール・メトリクス
リファクタリング効果の定量的評価手法：
- 複雑度測定: ESLintのcomplexityルールで最大複雑度を制限（推奨：10以下）
- テストカバレッジ: Jest等でカバレッジ閾値を設定（推奨：80%以上）
- 対象ファイル: srcディレクトリ内のJavaScript・TypeScriptファイル
- 除外対象: テストファイル自体は測定対象外
- 品質ゲート: CI/CDで品質基準を満たさない場合は自動的に失敗

## リファクタリング計画・管理

### 計画立案プロセス
```
□ 優先順位付け: リスク・効果・コストを考慮した計画策定
□ 段階的実行: 大規模リファクタリングの段階的分割実行
□ チーム合意: リファクタリング方針・スケジュールのチーム共有
□ ドキュメント更新: 設計変更に伴う文書・コメントの同期更新
□ 影響範囲分析: 変更が他システム・チームに与える影響評価
□ ロールバック準備: 問題発生時の迅速な元状態復旧手順
```

### 大規模リファクタリング計画例
レガシー認証システム更新の計画要素：
- 目標設定: セキュリティ向上（OAuth 2.0 + JWT）、パフォーマンス改善（30%高速化）、保守性向上（カバレッジ90%）
- フェーズ1（基盤整備・2週間）: 新認証モジュール設計・実装、テスト環境構築、移行ツール作成
- フェーズ2（段階移行・4週間）: 新規ユーザーから適用、既存ユーザー段階移行（週20%ずつ）、並行運用
- フェーズ3（完全移行・1週間）: 全ユーザー移行、旧システム無効化、監視・最適化
- リスク管理: ロールバック手順、段階的移行、24/7監視体制

## 避けるべきリファクタリング

### 危険なパターン
```
□ 機能変更混在: リファクタリングと新機能追加の同時実行
□ 大規模一括変更: 一度に広範囲を変更する危険な作業
□ テスト不十分: 不完全なテストカバレッジでの構造変更
□ 過度な最適化: 測定なしの憶測による不要なパフォーマンス調整
□ 流行追随: 明確な理由なく新技術・パターンを導入
□ 無計画実行: 目的・範囲・影響を検討しない場当たり的変更
```

### アンチパターンの具体例
機能変更とリファクタリングの混在問題：
- 問題パターン: 関数分割（リファクタリング）と新機能フラグ（機能追加）を同時実行
- 危険性: 問題発生時の原因特定困難、レビューの複雑化、ロールバック困難
- 正しいアプローチ: Step 1でリファクタリングのみ実行、Step 2で新機能を別PRで追加
- 分離の利点: 各変更の影響範囲明確化、段階的な品質確認、安全なロールバック

## ツール・自動化

### 推奨ツール
- **JavaScript/TypeScript**: 
  - ESLint (コード品質)
  - Prettier (フォーマット)
  - JSCodeshift (自動リファクタリング)
  - SonarQube (静的解析)

- **Java**: 
  - IntelliJ IDEA (IDE内蔵リファクタリング)
  - SpotBugs (バグ検出)
  - PMD (コード品質)

- **Python**: 
  - Black (フォーマット)
  - PyLint (静的解析)
  - Rope (リファクタリングライブラリ)

### 自動リファクタリング例
JSCodeshiftを使用した自動リファクタリング手法：
- 対象: var宣言からconst/letへの自動変換
- 判定ロジック: 再代入の有無による適切な宣言種別の選択
- 安全性: 再代入がない場合のみconstに変換、それ以外はletを使用
- 適用範囲: プロジェクト全体のファイルに対する一括変換
- 効果: 手動変換の工数削減と変換ミスの防止

## 継続的改善

### リファクタリング文化の醸成
- **定期的なコードレビュー**: リファクタリング観点での品質チェック
- **リファクタリング時間の確保**: スプリント時間の10-15%をリファクタリングに割当
- **学習・共有**: 効果的なリファクタリング事例の共有
- **メトリクス監視**: コード品質メトリクスの継続的追跡

### 成功事例の記録
効果的なリファクタリングの記録方法：
- 事例1（認証モジュール分離）: 巨大クラス（500行）を4つの専門クラス（各100-150行）に分離、バグ修正時間50%短縮・テストカバレッジ95%達成
- 事例2（データベース層抽象化）: 分散したSQL文をRepositoryパターンで統一、データベース移行時間90%短縮
- 記録要素: Before/After状況、定量的効果、学習点
- 活用方法: 今後の類似リファクタリングの参考資料として蓄積

## 参考リソース

### 関連ファイル
- メインルール: `@.cursor\rules\agent\fullstack-programmer.mdc`
- ログ実装: `@.cursor\rules\agent\fullstack-extensions\logging-guidelines.mdc`
- 文書化: `@.cursor\rules\agent\fullstack-extensions\documentation-standards.mdc`

### 推奨図書・リソース
- **書籍**: "Refactoring" by Martin Fowler
- **オンライン**: Refactoring.Guru
- **ツール**: IDE内蔵リファクタリング機能の活用

