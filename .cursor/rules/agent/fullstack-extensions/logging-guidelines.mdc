---
alwaysApply: false
---
# ログ機能実装ガイドライン

## 概要
このガイドラインは、`@.cursor\rules\agent\fullstack-programmer.mdc` の拡張ファイルとして、高品質なログ機能の実装方法を詳細に説明します。運用・デバッグ・監視の各視点から、効果的なログ戦略を提供します。

## ログレベル定義・使い分け

### 標準ログレベル
```
□ TRACE: 詳細なデバッグ情報（関数入退場・変数値）
□ DEBUG: 開発時デバッグ情報（処理フロー・状態変化）
□ INFO: 重要な業務イベント（ユーザー操作・システム状態変化）
□ WARN: 警告事象（非推奨機能使用・パフォーマンス劣化）
□ ERROR: エラー事象（例外発生・処理失敗）
□ FATAL: システム停止級の致命的エラー
```

### レベル選択の基準
- **TRACE**: 開発・デバッグ時のみ有効。本番環境では無効化
- **DEBUG**: 問題調査時に一時的に有効化。通常は無効
- **INFO**: 本番環境で常時有効。システムの正常動作を記録
- **WARN**: 本番環境で常時有効。潜在的問題の早期発見
- **ERROR**: 本番環境で常時有効。確実にアラート対象
- **FATAL**: 即座にシステム管理者に通知

## ログメッセージ設計

### 構造化ログの実装
構造化ログはJSON形式で以下の要素を含む：
- timestamp: ISO 8601形式のタイムスタンプ
- level: ログレベル（INFO、ERROR等）
- message: 人間が読める簡潔なメッセージ
- requestId: リクエスト追跡用の一意識別子
- userId: ユーザー識別子
- source: ファイル名、関数名、行番号
- context: ユーザーエージェント、IPアドレス、セッションID
- metrics: レスポンス時間、メモリ使用量等

### 設計原則
```
□ 構造化ログ: JSON形式で機械可読性を確保
□ 一意識別子: リクエストID・セッションIDで追跡可能
□ コンテキスト情報: ユーザーID・操作内容・時刻を含む
□ 検索性: キーワード・タグでフィルタリング可能
□ 可読性: 人間が理解しやすいメッセージ形式
```

### メッセージフォーマット規則
- **簡潔性**: 重要な情報を50文字以内で表現
- **一貫性**: 同種の操作は同一フォーマットを使用
- **国際化**: 英語での記述、文字コード統一
- **動詞ベース**: "User logged in" より "Login successful"

## ログ出力タイミング

### 必須ログポイント
```
□ 関数開始・終了: 重要な処理の境界
□ 外部依存: API呼び出し・DB操作の開始・結果
□ 分岐処理: 条件判定・例外ハンドリングの分岐点
□ 状態変化: データ更新・ステータス変更
□ パフォーマンス: 処理時間測定・リソース使用量
```

### 実装例の考慮点
支払い処理のような重要な処理では以下のログを出力：
- 処理開始時: リクエストID、ユーザーID、金額を記録
- 外部API呼び出し前後: デバッグレベルでAPI呼び出し、結果ステータスを記録
- 状態変化時: データ更新やステータス変更を記録
- 処理完了時: 処理時間を含む完了ログ
- エラー発生時: エラーメッセージとスタックトレースを記録

## ログセキュリティ・品質

### セキュリティ要件
```
□ 機密情報除外: パスワード・トークン・個人情報をマスク
□ ログ改ざん防止: ハッシュ・署名による完全性保証
□ アクセス制御: ログファイル・ビューアーの権限管理
□ ローテーション: ファイルサイズ・保存期間の管理
□ パフォーマンス影響: 非同期出力・バッファリング活用
```

### 機密情報マスキング実装
機密情報の自動マスキング機能を実装：
- 対象フィールド: password、token、ssn、creditCard等
- マスキング方式: 完全置換（例：'***MASKED***'）
- ネストオブジェクト対応: 再帰的にオブジェクト内部もマスキング
- 設定可能: 機密フィールドリストの動的設定
- パフォーマンス考慮: 浅いコピーでメモリ効率化

### パフォーマンス最適化
非同期ログ処理によるパフォーマンス向上：
- バッファリング: 複数ログを一括処理（例：100件単位）
- 非同期書き込み: メインプロセスをブロックしない
- 定期フラッシュ: 時間間隔でのバッファ自動クリア（例：1秒間隔）
- バッチサイズ制御: メモリ使用量の調整
- 自動マスキング統合: 機密情報処理との組み合わせ

## デバッグ・運用活用

### 運用監視での活用
```
□ エラー再現: ログ情報から問題の再現手順を特定
□ パフォーマンス分析: 処理時間・リソース使用パターン把握
□ ユーザー行動分析: 操作フロー・使用パターン把握
□ システム監視: 異常検知・アラート条件設定
□ 監査証跡: セキュリティインシデント・コンプライアンス対応
```

### アラート設定例
監視システムでのアラート設定例：
- 高エラー率: 5分間でエラー率が10%を超過
- 応答時間: 95パーセンタイルが1秒を超過
- メモリ使用率: 全体の80%を超過
各アラートには明確なメッセージと対処法を含める

### ログ分析クエリ例
効果的なログ分析のためのクエリパターン：
- エラー傾向分析: 時間別エラー件数と影響ユーザー数の集計
- パフォーマンス分析: 関数別の平均・95パーセンタイル応答時間
- ユーザー行動分析: ユーザー別の操作パターン追跡
- システム負荷分析: リソース使用量の時系列変化

## 実装ベストプラクティス

### ログ設定管理
環境別ログ設定の考慮点：
- 開発環境: DEBUGレベル、コンソール出力、読みやすい形式
- ステージング環境: INFOレベル、ファイル出力、JSON形式、ローテーション設定
- 本番環境: WARNレベル以上、Elasticsearch等集約システム、JSON形式
各環境に応じた適切なレベル・出力先・形式の設定が重要

### コンテキスト保持パターン
リクエストコンテキストの自動管理：
- ミドルウェアでコンテキスト情報を自動追加
- リクエストID、ユーザーID、User-Agent、IPアドレスの収集
- 子ロガーでコンテキスト情報の引き継ぎ
- 全ハンドラーで統一されたコンテキスト利用

### テスト時のログ設定
テスト環境での効率的なログ管理：
- テスト時のログ出力無効化（パフォーマンス向上）
- テスト用ログキャプチャクラスの実装
- ログ内容の検証機能
- テスト後のログクリア機能

## 品質管理

### ログ品質チェックリスト
```
□ 機密情報のマスキング確認
□ ログレベルの適切な使い分け
□ 構造化データの一貫性
□ パフォーマンス影響の測定
□ ログローテーション設定
□ 監視・アラート設定
□ バックアップ・復旧手順
□ 法的要件への準拠
```

### 継続的改善
- **ログ利用状況分析**: 実際にどのログが活用されているか
- **ノイズ削減**: 不要なログの除去・レベル調整
- **フォーマット最適化**: 検索・分析効率の向上
- **ツール評価**: ログ管理ツールの定期的見直し

## 参考リソース

### 関連ファイル
- メインルール: `@.cursor\rules\agent\fullstack-programmer.mdc`
- 文書化: `@.cursor\rules\agent\fullstack-extensions\documentation-standards.mdc`

### 推奨ツール
- **Node.js**: Winston, Bunyan, Pino
- **Java**: Logback, Log4j2
- **Python**: Structlog, Loguru
- **監視**: ELK Stack, Splunk, Datadog
